---
title: "Block Bootstrap for Time Series"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

We need to start with a sample of a certain size B of consecutive points from a time series ts.series. First we need to randomly select a single point in the time series, and we can do this by selecting a number between 1 and 100.

```{r, echo = False}
ts.sim <- arima.sim(list(order = c(1, 0, 0), ar = 0.5), n = 100) 
single_point <- function(ts.series)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  print(ts.series)
  print(point1)
}
single_point(ts.sim)
```

one_sample creates the sample that we'll be working with now

```{r, echo = False}
one_sample <- function(ts.series, B)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.sim[point1 + i - 1])
  }
  print(ts.series)
  plot(ts.series)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
}
one_sample(ts.sim, 10)
```

Now we need to separate the sample into blocks of size b. We are assuming that B is divisible by b.

```{r, echo == False}
blocks <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.series[point1 + i - 1])
  }
  print(ts.series)
  plot(ts.series)
  print(point1)
  print(ts.samp1)
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  plot(ts.samp1, type = 'l')
}
blocks(ts.sim, 20, 4)
```

Randomly samples B/b non-overlapping blocks (with replacement) from ts.block_list, creating a single bootstrapped time series. 
```{r, echo = False}
bootstrap_samp1 <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.series[point1 + i - 1])
  }
  print(ts.series)
  plot(ts.series)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  ts.bootstrap_1 <- sample(ts.block_list, B/b, replace = T)
  print(ts.bootstrap_1)
  class(ts.boot1)
}
bootstrap_samp1(ts.sim, 20, 4)
```

ts.bootstrap_1 is a list of lists and will be difficult to work with, so we use a nested loop to store the values in ts.bootstrap_2, a simpler numeric vector

```{r, echo = False}
bootstrap_samp2 <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.series[point1 + i - 1])
  }
  print(ts.series)
  plot(ts.series)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  ts.bootstrap_1 <- sample(ts.block_list, B/b, replace = T)
  print(ts.bootstrap_1)
  class(ts.boot1)
  ts.bootstrap_2 <- c()
  for(i in 1 : (B/b)) {
    for(j in 1 : b) {
      ts.bootstrap_2 <- c(ts.bootstrap_2, ts.bootstrap_1[[i]][[j]])
    }
  }
  print(ts.bootstrap_2)
  class(ts.bootstrap_2)
  plot(ts.bootstrap_2, type = 'l')
}
bootstrap_samp2(ts.sim, 20, 4)
```
Now we can find the mean of this bootstrap, repeat the process many times, and find the point estimate for the mean and the standard error of the distribution (or the standard deviation of the sample mean).
```{r, echo = False}
samp_dist <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.series[point1 + i - 1])
  }
  plot(ts.series)
  plot(ts.samp1, type = 'l')
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  samp_mean <- c()
  for(i in 1 : 1000)
  {
    ts.bootstrap_1 <- sample(ts.block_list, B/b, replace = T)
    ts.bootstrap_2 <- c()
    for(i in 1 : (B/b)) {
      for(j in 1 : b) {
        ts.bootstrap_2 <- c(ts.bootstrap_2, ts.bootstrap_1[[i]][[j]])
      }
    }
    samp_mean <- c(samp_mean, mean(ts.bootstrap_2))
  }
  return(c(mean(samp_mean), sd(samp_mean)))
  
  
}
print(samp_dist(ts.sim, 20, 4))
```

Let's test how well the function works now with a larger time series and a larger sample size:
```{r, echo = False}
ts.sim1 <- arima.sim(list(order = c(1, 0, 0), ar = 0.5), n = 1000)
print(samp_dist(ts.sim1, 100, 10))
print(mean(ts.sim1))
```