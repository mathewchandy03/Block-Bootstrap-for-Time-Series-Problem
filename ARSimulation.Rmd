---
title: "Block Bootstrap for Time Series"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Simulates, prints, and plots auto-regressive process of order 1 with ar = 0.5 and size = 100
```{r, echo = FALSE}
ts.sim <- arima.sim(list(order = c(1, 0, 0), ar = 0.5), n = 100) 
ts.sim
plot(ts.sim)
```

Splits time series into ten blocks of size 10 and stores them in a list
```{r, echo = False}
ts.blocks <- list(ts.sim[c(1 : 10)], ts.sim[c(11 : 20)], ts.sim[c(21 : 30)], ts.sim[c(31 : 40)], ts.sim[c(41 : 50)], ts.sim[c(51 : 60)], ts.sim[c(61 : 70)], ts.sim[c(71 : 80)], ts.sim[c(81 : 90)], ts.sim[c(91 : 100)])
ts.blocks
```

Randomly samples 10 non-overlapping blocks (with replacement) from ts.blocks, creating a single bootstrapped time series
```{r, echo = False}
ts.boot1 <- sample(ts.blocks, 10, replace = T)
ts.boot1
class(ts.boot1)
```

ts.boot1 is a list of vectors and does not work with the plot() function, so we use a nested loop to store the values in ts.boot2, a simpler numeric vector
```{r, echo = False}
ts.boot2 <- c()
for(i in 1 : 10) {
  for(j in 1 : 10) {
    ts.boot2 <- c(ts.boot2, ts.boot1[[i]][[j]])
  }
}
ts.boot2
class(ts.boot2)
```

Ts.boot2 is plotted
```{r, echo = False}
plot(ts.boot2, type = "l")
```
We need to start with a sample of a certain size B of consecutive points from a time series ts.series. First we need to randomly select a single point in the time series, and we can do this by selecting a number between 1 and 100.

```{r, echo = False}
ts.sim <- arima.sim(list(order = c(1, 0, 0), ar = 0.5), n = 100) 
single_point <- function(ts.series)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  print(ts.sim)
  print(point1)
}
single_point(ts.sim)
```

one_sample creates the sample that we'll be working with now

```{r, echo = False}
one_sample <- function(ts.series, B)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.sim[point1 + i - 1])
  }
  print(ts.sim)
  plot(ts.sim)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
}
one_sample(ts.sim, 10)
```

Now we need to separate the sample into blocks of size b. We are assuming that B is divisible by b.

```{r, echo == False}
blocks <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.sim[point1 + i - 1])
  }
  print(ts.sim)
  plot(ts.sim)
  print(point1)
  print(ts.samp1)
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  plot(ts.samp1, type = 'l')
}
blocks(ts.sim, 20, 4)
```

Randomly samples B/b non-overlapping blocks (with replacement) from ts.block_list, creating a single bootstrapped time series. 
```{r, echo = False}
bootstrap_samp1 <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.sim[point1 + i - 1])
  }
  print(ts.sim)
  plot(ts.sim)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  ts.bootstrap_1 <- sample(ts.block_list, B/b, replace = T)
  print(ts.bootstrap_1)
  class(ts.boot1)
}
bootstrap_samp1(ts.sim, 20, 4)
```

ts.bootstrap_1 is a list of lists and will be difficult to work with, so we use a nested loop to store the values in ts.bootstrap_2, a simpler numeric vector

```{r, echo = False}
bootstrap_samp2 <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.sim[point1 + i - 1])
  }
  print(ts.sim)
  plot(ts.sim)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  ts.bootstrap_1 <- sample(ts.block_list, B/b, replace = T)
  print(ts.bootstrap_1)
  class(ts.boot1)
  ts.bootstrap_2 <- c()
  for(i in 1 : (B/b)) {
    for(j in 1 : b) {
      ts.bootstrap_2 <- c(ts.bootstrap_2, ts.bootstrap_1[[i]][[j]])
    }
  }
  print(ts.bootstrap_2)
  class(ts.bootstrap_2)
  plot(ts.bootstrap_2, type = 'l')
}
bootstrap_samp2(ts.sim, 20, 4)
```
Now we can find the mean of this bootstrap, repeat the process many times, and find the point estimate for the mean and the standard error of the distribution (or the standard deviation of the sample mean).
```{r, echo = False}
samp_dist <- function(ts.series, B, b)
{
  point1 <- sample(c(1:length(ts.series)), 1, replace = T)
  ts.samp1 <- c()
  for(i in 1 : B)
  {
    ts.samp1 <- c(ts.samp1, ts.sim[point1 + i - 1])
  }
  print(ts.sim)
  plot(ts.sim)
  print(point1)
  print(ts.samp1)
  plot(ts.samp1, type = 'l')
  i <- 1
  ts.block_list <- list()
  while(i < B)
  {
    x <- list(ts.samp1[i : (i + b - 1)])
    ts.block_list <- append(ts.block_list, x)
    i = i + b
  }
  print(ts.block_list)
  samp_mean <- c()
  for(i in 1 : 1000)
  {
    ts.bootstrap_1 <- sample(ts.block_list, B/b, replace = T)
    ts.bootstrap_2 <- c()
    for(i in 1 : (B/b)) {
      for(j in 1 : b) {
        ts.bootstrap_2 <- c(ts.bootstrap_2, ts.bootstrap_1[[i]][[j]])
      }
    }
    samp_mean <- c(samp_mean, mean(ts.bootstrap_2))
  }
  print(samp_mean)
  return(c(mean(samp_mean), sd(samp_mean)))
  
  
}
print(samp_dist(ts.sim, 20, 4))
```